<!DOCTYPE html>
<html>
<head>
    <title>AI Voice Assistant</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://js.pusher.com/8.2.0/pusher.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <div class="status-text">
                <div class="status-label" id="statusLabel">Connecting...</div>
                <div class="status-url" id="statusUrl"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // Get server URL from query parameters
        const params = new URLSearchParams(window.location.search);
        const SERVER_URL = params.get('server') || 'https://zoom-bot-zkf2.vercel.app';
        const PUSHER_KEY = params.get('pusher_key') || '53efc497795d6002deb2';
        const PUSHER_CLUSTER = params.get('pusher_cluster') || 'ap2';
        
        const statusDot = document.getElementById('statusDot');
        const statusLabel = document.getElementById('statusLabel');
        const statusUrl = document.getElementById('statusUrl');

        const sessionId = 'session-' + Math.random().toString(36).substr(2, 9);

        function updateStatus(status, message) {
            statusDot.className = 'status-dot ' + status;
            statusLabel.textContent = message;
            statusUrl.textContent = SERVER_URL;
        }

        async function connectToServer() {
            try {
                updateStatus('connecting', 'Connecting to AI...');
                
                // Initialize Pusher
                const pusher = new Pusher(PUSHER_KEY, {
                    cluster: PUSHER_CLUSTER
                });
                
                // Subscribe to session channel
                const channel = pusher.subscribe(`session-${sessionId}`);
                
                // Listen for OpenAI messages
                channel.bind('openai-message', (message) => {
                    console.log('Received from OpenAI:', message.type);
                    
                    if (message.type === 'response.audio.delta' && message.delta) {
                        playAudio(message.delta);
                    }
                    
                    if (message.type === 'session.created') {
                        updateStatus('connected', 'Connected to AI');
                    }
                });
                
                // Connect to backend
                const response = await fetch(`${SERVER_URL}/api/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId })
                });
                
                if (!response.ok) throw new Error('Connection failed');
                
                // Start capturing audio
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioContext = new AudioContext({ sampleRate: 24000 });
                const source = audioContext.createMediaStreamSource(stream);
                
                await audioContext.audioWorklet.addModule(createAudioProcessor());
                const processor = new AudioWorkletNode(audioContext, 'audio-processor');
                
                source.connect(processor);
                
                // Send audio to server
                processor.port.onmessage = async (event) => {
                    const audioData = Array.from(event.data);
                    const base64Audio = btoa(String.fromCharCode(...new Uint8Array(event.data.buffer)));
                    
                    await fetch(`${SERVER_URL}/api/send-audio`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            sessionId, 
                            audio: base64Audio 
                        })
                    });
                };
                
            } catch (error) {
                console.error('Error:', error);
                updateStatus('disconnected', 'Error: ' + error.message);
            }
        }

        // Audio playback
        const audioContext = new AudioContext({ sampleRate: 24000 });
        const audioQueue = [];
        let isPlaying = false;

        function playAudio(base64Audio) {
            const audioData = Uint8Array.from(atob(base64Audio), c => c.charCodeAt(0));
            audioQueue.push(audioData);
            
            if (!isPlaying) {
                processAudioQueue();
            }
        }

        async function processAudioQueue() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                return;
            }
            
            isPlaying = true;
            const audioData = audioQueue.shift();
            
            const audioBuffer = audioContext.createBuffer(1, audioData.length / 2, 24000);
            const channelData = audioBuffer.getChannelData(0);
            
            for (let i = 0; i < channelData.length; i++) {
                const int16 = (audioData[i * 2 + 1] << 8) | audioData[i * 2];
                channelData[i] = int16 / 32768.0;
            }
            
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            source.onended = processAudioQueue;
            source.start();
        }

        function createAudioProcessor() {
            const processorCode = `
                class AudioProcessor extends AudioWorkletProcessor {
                    process(inputs, outputs) {
                        const input = inputs[0];
                        if (input && input[0]) {
                            const samples = input[0];
                            const int16 = new Int16Array(samples.length);
                            for (let i = 0; i < samples.length; i++) {
                                int16[i] = Math.max(-32768, Math.min(32767, samples[i] * 32768));
                            }
                            this.port.postMessage(int16);
                        }
                        return true;
                    }
                }
                registerProcessor('audio-processor', AudioProcessor);
            `;
            
            const blob = new Blob([processorCode], { type: 'application/javascript' });
            return URL.createObjectURL(blob);
        }

        connectToServer();
    </script>
</body>
</html>